#include "mainwindow.h"

#include <QApplication>

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    MainWindow w;
    w.show();
    return a.exec();
}

// 我们已经知道了别人写好的播放器是不能直接播放.pcm文件的，因为.pcm文件没有文件头，里面存放的全是PCM音频数据，所以播放器根本不知道这段音频数据的采样率、采样大小、声道数等参数，因此无从播放
// 不过如果我们把.pcm文件转换成特定格式的文件，播放器就能直接播放了，就是因为特定格式的文件会在PCM数据前面加文件头，文件头里就有这段音频数据的采样率、采样大小、声道数等参数，因此可以播放
// 但是到目前为止我们还没有学习到音频编码相关的知识，所以还无法涉及.flac/opus/.aac/.mp3等更多的文件格式，因此这里我们只能先将PCM数据存进.wav文件里，因为只有.wav文件可以直接存储PCM数据
//
// 那么这个demo的目标就是：把一个已有的.pcm文件转换成一个.wav文件，以便我们能直接通过播放器来播放这段音频

// 一、在进行pcm2wav之前，我们先学习一下.wav文件的格式
// .wav文件通常有44个字节的文件头，后面跟的就是PCM数据，.wav文件头里除了那几个固定的字符串是大端存储、其它的都是小端存储
//
// 1、[0, 3]4个字节：固定是字符串“RIFF”，代表.wav文件是基于RIFF标准的文件格式
// 2、[4, 7]4个字节：代表整个.wav文件除了（[0, 3]4个字节 + [4, 7]4个字节）以外的大小，即整个.wav文件的大小 - 4个字节 - 4个字节
//
// 3、[8, 11]4个字节：固定是字符串“WAVE”，代表文件的类型是“.wav”
//
// 4、[12, 15]4个字节：固定是字符串“fmt”，代表接下来的一段数据是要存储音频数据的采样率、采样大小、声道数等参数了，因为“fmt”只占3个字节，所以另外1个字节会被自动填充为空格
// 5、[16, 19]4个字节：代表“要描述音频数据的采样率、采样大小、声道数等参数”这段数据的大小，其实固定为16个字节 = 6 + 7 + 8 + 9 + 10 + 11几个部分加起来的大小
// 6、[20, 21]2个字节：AudioFormat，代表音频的格式，可以理解为文件最后面存储的是什么音频数据，1代表是“以int类型存储PCM数据、即采样格式类似于s16le之类的”，3代表是“以float类型存储PCM数据、即采样格式类似于f32le之类的”
// 这个一定要搞对，否则转出来的.wav文件播放起来会有噪音
// 7、[22, 23]2个字节：NumChannels，代表音频的声道数，1是单声道，2是双声道
// 8、[24, 27]4个字节：SampleRate，代表音频的采样率
// 9、[28, 31]4个字节：ByteRate，代表音频的字节率 = 比特率 / 8 = 采样率 * 采样大小 * 声道数 / 8 = SampleRate * BitsPerSample * NumChannels / 8
// 10、[32, 33]2个字节：BlockAlign，固定的计算公式 = 一个样本的位数 * 通道数 / 8 = BitsPerSample * NumChannels / 8
// 11、[34, 35]2个字节：BitsPerSample，代表音频的采样大小
//
// 12、[36, 39]4个字节：固定为“data”，代表接下来的一段数据是要存储PCM数据了
// 13、[40, 43]4个字节：代表后面跟着的PCM数据一共有多少个字节
// 14、后面的若干个字节：PCM数据

// 二、知道了.wav文件的格式，接下来我们就创建一个工具类来完成pcm2wav，详见FFmpegUtil
